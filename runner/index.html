<!doctype html>
<html>
    <head>
        <title>Creatures</title>
        <meta charset="utf-8">
        <script src="../umd/world.js"></script>
        <style type="text/css">
            body {
                display: flex;
                justify-content: space-between;

                padding: 1em;
                margin: 0;
            }

            canvas {
                border: thin solid black;
            }

            #info {
                flex-grow: 1;
                padding-left: 1em;
            }

            #log {
                white-space: pre;
            }

            #program {
                max-width: 35em;
                overflow-x: auto;
                white-space: pre;
            }

            #creatureState {
                white-space: pre;
            }

            #graphviz {
                white-space: pre;
            }
        </style>
    </head>
    <body>
        <div>
            <div>
                X: <span id="xOffset"></span>, Y: <span id="yOffset"></span>,
                Scale: <span id="scale"></span>,
                Mouse: (<span id="mouseX"></span>, <span id="mouseY"></span>)
            </div>
            <canvas id="view" width="1000" height="1000"></canvas>
        </div>
        <div id="info">
            <div>
                <button id="startButton" type="button">Start</button>
                <button id="stopButton" type="button">Stop</button>
                <div id="settings">
                    <dl>
                        <dt>Elapsed Seconds</dt><dd id="elapsedSeconds"></dd>
                        <dt>Update Seconds</dt><dd id="updateSeconds"></dd>
                        <dt>Simulation Time:</dt><dd id="simulationTime"></dd>
                        <dt>Speed:</dt><dd><input id="speed" type="number" value="1"></dd>
                    </dl>
                </div>
            </div>
            <div>
                <canvas id="sprite" width="64" height="64"></canvas>
                <div id="program">
                </div>
                <div>
                    <dl>
                        <dt>Id:</dt><dd id="creatureId"></dd>
                        <dt>Carnivore:</dt><dd id="creatureIsCarnivore"></dd>
                        <dt>Age:</dt><dd id="creatureAge"></dd>
                        <dt>Angle:</dt><dd id="creatureAngle"></dd>
                        <dt>Health:</dt><dd id="creatureHealth"></dd>
                        <dt>Speed:</dt><dd id="creatureSpeed"></dd>
                        <dt>X:</dt><dd id="creatureX"></dd>
                        <dt>Y:</dt><dd id="creatureY"></dd>
                    </dl>
                </div>
                <div id="creatureState">
                </div>
            </div>
            <div>
                <button id="renderGraphviz" type="button">
                    Render Graphviz
                </button>
            </div>
            <div id="log">
            </div>
            <div id="graphviz">
            </div>
        </div>
    </body>
    <script>
        const transform = {
            scale: 1,
            xOffset: 0,
            yOffset: 0
        };

        const sprites = new Image();
        sprites.src = 'MuteraMap.png';

        const spriteWidth = 16;
        const spriteHeight = 16;
        const colorColumns = {
            black: 0,
            white: 1,
            purple: 2,
            green: 3,
            blue: 4,
            cyan: 5,
            red: 6,
            yellow: 7
        };

        const herbivoreBodyRow = 0;
        const carnivoreBodyRow = 1;

        function renderGraphViz(genealogy, graphviz) {
            let text = 'strict digraph {\n';
            genealogy.forEach((parentIds, id) => {
                text += `\t"${id}" -> {`;
                parentIds.forEach(id => text += ` "${id}" `);
                text += '}\n';
            });

            text += `}`;

            graphviz.textContent = text;
        }

        let selectedCreature = null;

        const mapWidth = 2000;
        const mapHeight = 2000;

        function canvasToMap(point) {
            return {
                x: point.x / transform.scale + transform.xOffset,
                y: point.y / transform.scale + transform.yOffset
            };
        }

        function drawSprite(context, row, column, adjustX = 0, adjustY = 0) {
            context.drawImage(
                sprites,
                column * spriteWidth,
                row * spriteHeight,
                spriteWidth,
                spriteHeight,
                -spriteWidth / 2 + adjustX,
                -spriteHeight / 2 + adjustY,
                spriteWidth,
                spriteHeight);
        }

        function drawFood(context, point) {
            context.save();
            context.translate(point.x, point.y);

            const foodRow = 1;
            const foodColumn = 8;
            drawSprite(context, foodRow, foodColumn);

            context.restore();
        }

        function drawEgg(context, egg) {
            const point = egg.creature;

            context.save();
            context.translate(point.x, point.y);

            const eggRow = 0;
            const eggColumn = 9;
            drawSprite(context, eggRow, eggColumn);

            context.restore();

            const gestationWidth = Math.floor(egg.elapsedGestationTime * 10 / egg.gestationTime);
            context.fillStyle = `rgb(0, 255, 0)`;
            context.fillRect(point.x - 5, point.y - 10, gestationWidth, 3);
            context.fillStyle = `rgb(0, 0, 0)`;
            context.fillRect(point.x - 5 + gestationWidth, point.y - 10, 10 - gestationWidth, 3);
        }

        function getCreatureColor(creature) {
            if (creature.isRed && creature.isGreen && creature.isBlue) {
                return 'white';
            } else if (creature.isRed && creature.isGreen && !creature.isBlue) {
                return 'yellow';
            } else if (creature.isRed && !creature.isGreen && creature.isBlue) {
                return 'purple';
            } else if (creature.isRed && !creature.isGreen && !creature.isBlue) {
                return 'red';
            } else if (!creature.isRed && creature.isGreen && creature.isBlue) {
                return 'cyan';
            } else if (!creature.isRed && creature.isGreen && !creature.isBlue) {
                return 'green';
            } else if (!creature.isRed && !creature.isGreen && creature.isBlue) {
                return 'blue';
            }

            return 'black';
        }

        function drawCreatureSprite(context, creature) {
            const color = getCreatureColor(creature);
            const colorColumn = colorColumns[color];
            const bodyRow = creature.isCarnivore ? carnivoreBodyRow : herbivoreBodyRow;

            drawSprite(context, bodyRow, colorColumn);

            const feetRow = 2 + creature.legs;
            drawSprite(context, feetRow, colorColumn);

            const eyeRow = 5;
            const eyeColumn = creature.eyes;
            drawSprite(context, eyeRow, eyeColumn);

            const mouthRow = 5;
            const mouthColumn = creature.mouth;
            drawSprite(context, mouthRow, mouthColumn);

            if (creature.isAggressive) {
                const aggressiveRow = 4;
                const aggressiveColumn = 9;
                drawSprite(context, aggressiveRow, aggressiveColumn, 0, 18);
            }

            if (creature.shouldReproduceAsexually) {
                const asexualRow = 3;
                const asexualColumn = 8;
                drawSprite(context, asexualRow, asexualColumn, 5, 18);
            }

            if (creature.shouldReproduceSexually) {
                const sexualRow = 4;
                const sexualColumn = 8;
                drawSprite(context, sexualRow, sexualColumn, 10, 18);
            }
        }

        function drawViewSector(context, creature) {
            const sector = creature.visualField.periphery;
            const frustrumLength = sector.radius;
            let frustrumAngle;
            if (sector.centerAngle < sector.toAngle) {
                frustrumAngle = (sector.toAngle - sector.centerAngle);
            } else {
                frustrumAngle = (sector.centerAngle - sector.fromAngle);
            }

            const leftEndpoint = {
                x: frustrumLength * Math.cos(frustrumAngle),
                y: frustrumLength * Math.sin(frustrumAngle)
            };

            const focusLeftEndpoint = {
                x: frustrumLength * Math.cos(frustrumAngle / 3),
                y: frustrumLength * Math.sin(frustrumAngle / 3)
            };

            context.setLineDash([4, 4]);
            context.strokeStyle = 'lightgrey';

            context.beginPath();
            context.moveTo(0, 0);
            context.lineTo(
                leftEndpoint.x,
                leftEndpoint.y);
            context.arc(
                0,
                0,
                frustrumLength,
                frustrumAngle,
                -frustrumAngle,
                true);
            context.lineTo(0, 0);
            context.stroke();

            context.setLineDash([]);
            context.strokeStyle = 'lightgrey';

            context.beginPath();
            context.moveTo(0, 0);
            context.lineTo(
                focusLeftEndpoint.x,
                focusLeftEndpoint.y);
            context.arc(
                0,
                0,
                frustrumLength,
                frustrumAngle / 3,
                -frustrumAngle / 3,
                true);
            context.lineTo(0, 0);
            context.stroke();
        }

        function drawCreature(context, creature) {
            const point = creature;

            context.save();
            context.translate(point.x, point.y);
            context.rotate(creature.angle);

            const healthWidth = Math.floor(creature.health * 10 / 4096);
            context.fillStyle = `lime`;
            context.fillRect(-5, -15, healthWidth, 3);
            context.fillStyle = `black`;
            context.fillRect(-5 + healthWidth, -15, 10 - healthWidth, 3);

            drawViewSector(context, creature);
            drawCreatureSprite(context, creature);

            if (selectedCreature === creature) {
                context.beginPath();
                context.arc(0, 0, 10, 0, 2 * Math.PI);
                context.strokeStyle = 'blue';
                context.stroke();
            }

            context.restore();
        }

        function render(context, environment) {
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(
                0,
                0,
                mapWidth,
                mapHeight);
            context.restore();

            environment.map.foodLocations.forEach(point => drawFood(context, point));

            environment.map.eggs.forEach(
                egg => drawEgg(context, egg));

            environment.creatures.forEach(
                creature => drawCreature(context, creature));
        }

        function distance(a, b) {
            return Math.sqrt(
                (a.x - b.x) * (a.x - b.x) +
                (a.y - b.y) * (a.y - b.y));
        }

        function handleClick(point, environment) {
            let creature = Array.from(environment.creatures.values()).
                find(creature => distance(point, creature) < (spriteWidth / transform.scale));
            if (!creature) {
                const egg = environment.map.eggs.find(egg =>
                    distance(point, egg) < (spriteWidth / transform.scale));
                if (egg) {
                    creature = egg.creature;
                }
            }
            selectCreature(creature);
        }

        const renderedOperators = {
            [world.DNA.operators.greaterThan]: '>',
            [world.DNA.operators.lessThan]: '<',
            [world.DNA.operators.and]: 'and',
            [world.DNA.operators.or]: 'or',
            [world.DNA.operators.not]: 'not',
            [world.DNA.operators.add]: '+',
            [world.DNA.operators.subtract]: '-',
            [world.DNA.operators.multiply]: '*',
            [world.DNA.operators.divide]: '/'
        };

        function renderReal(real) {
            const known = {
                g: 'age',
                a: 'angle',
                A: 'angularV',
                h: 'health',
                s: 'speed',
                l: 'leftFoodDistance',
                r: 'rightFoodDistance',
                f: 'focusFoodDistance',
                H: 'leftCreatureDistance',
                L: 'rightCreatureDistance',
                P: 'focusCreatureDistance',
                W: 'frontSound',
                X: 'leftSound',
                Y: 'backSound',
                Z: 'rightSound'
            };

            if (real in known) {
                return known[real];
            }

            return real;
        }

        function renderBoolean(boolean) {
            const known = {
                c: 'isRed',
                d: 'isGreen',
                e: 'isBlue',
                a: 'isAggressive',
                m: 'isMoving',
                r: 'shouldReproduceAsexually',
                s: 'shouldReproduceSexually',
                F: 'isFast',
                I: 'leftCreatureIsRed',
                J: 'leftCreatureIsGreen',
                K: 'leftCreatureIsBlue',
                B: 'leftCreatureIsCarnivore',
                M: 'rightCreatureIsRed',
                N: 'rightCreatureisGreen',
                O: 'rightCreatureIsBlue',
                C: 'rightCreatureIsCarnivore',
                Q: 'focusCreatureIsRed',
                R: 'focusCreatureIsGreen',
                S: 'focusCreatureIsBlue',
                D: 'focusCreatureIsCarnivore'
            };

            if (boolean in known) {
                return known[boolean];
            }

            return boolean;
        }

        function renderTree(tree) {
            if (tree.operator === world.DNA.operators.constant) {
                return world.DNA.constants[tree.data].toString();
            } else if (tree.operator === world.DNA.operators.real) {
                return renderReal(tree.data);
            } else if (tree.operator === world.DNA.operators.true) {
                return 'T';
            } else if (tree.operator === world.DNA.operators.boolean) {
                return renderBoolean(tree.data);
            }

            const rhs = tree.rhs ? ` ${renderTree(tree.rhs)}` : '';

            return `(${renderTree(tree.lhs)} ${renderedOperators[tree.operator]}${rhs})`;
        }

        function renderGene(gene) {
            const output = gene.isBoolean ?
                renderBoolean(gene.output) :
                renderReal(gene.output);
            return `if ${renderTree(gene.condition)}:\n\t${output} = ${renderTree(gene.expression)}\n`;
        }

        function renderProgram(creature) {
            const element = document.getElementById('program');
            if (creature) {
                const program = creature.dna.genes.reduce(
                    (aggregate, gene) => {
                        return aggregate += renderGene(gene);
                    },
                    '');

                element.textContent = program;
            } else {
                element.textContent = '';
            }
        }

        function renderCreatureState(creature) {
            const spriteCanvas = document.getElementById('sprite');
            const spriteContext = spriteCanvas.getContext('2d');
            spriteContext.clearRect(
                -spriteWidth / 2,
                -spriteHeight / 2,
                spriteCanvas.width,
                spriteCanvas.height);

            if (creature) {
                drawCreatureSprite(spriteContext, creature);
                document.getElementById('creatureId').textContent = creature.id;
                document.getElementById('creatureIsCarnivore').textContent = creature.isCarnivore;
                document.getElementById('creatureAge').textContent = creature.age;
                document.getElementById('creatureAngle').textContent = creature.angle;
                document.getElementById('creatureHealth').textContent = creature.health;
                document.getElementById('creatureSpeed').textContent = creature.speed;
                document.getElementById('creatureX').textContent = creature.x;
                document.getElementById('creatureY').textContent = creature.y;

                document.getElementById('creatureState').textContent =
                    JSON.stringify(creature.state, null, 2);
            } else {
                document.getElementById('creatureId').textContent = '';
                document.getElementById('creatureIsCarnivore').textContent = '';
                document.getElementById('creatureAge').textContent = '';
                document.getElementById('creatureAngle').textContent = '';
                document.getElementById('creatureHealth').textContent = '';
                document.getElementById('creatureSpeed').textContent = '';
                document.getElementById('creatureX').textContent = '';
                document.getElementById('creatureY').textContent = '';

                document.getElementById('creatureState').textContent = '';
            }
        }

        function selectCreature(creature) {
            selectedCreature = creature;
            renderProgram(creature);
        }

        const dnaSelector = new world.DNA.GenericSelector({
            geneBooleanRate: 5/6, //7/9,
            inputBooleans: 'BCD', //'BCDIJKMNOQRS',
            inputReals: 'hlrfHLP', //'hlrfHLPWXYZ',
            maximumTreeDepth: 2,
            mutationsPerGene: new Map([
                [0, 0.9],
                [1, 0.93],
                [2, 0.95],
                [3, 0.99]
            ]),
            outputBooleans: 'amFrs', //'amFcders',
            outputReals: 'A',
            spliceRates: new Map([
                [world.DNA.spliceType.delete, 0.1],
                [world.DNA.spliceType.duplicate, 0.55],
                [world.DNA.spliceType.insert, 1]
            ])
        });

        const makeDNA = encodedDNA =>
            new world.DNA.DNA(encodedDNA, dnaSelector);

        class CreatureSelector extends world.Creature.GenericSelector {
            createRandomDNA() {
                return world.DNA.DNA.createRandom(dnaSelector, makeDNA);
            }
        }

        const creatureSelector = new CreatureSelector();

        const creatureStateProcessor = new world.Creature.StateProcessor(-10, 2000, 2000);

        class EnvironmentSelector extends world.Environment.GenericSelector {
            constructor(options) {
                super(options);
            }

            createRandomCreature({ isCarnivore }) {
                return world.Creature.Creature.createRandom({
                    isCarnivore,
                    stateProcessor: creatureStateProcessor,
                    selector: creatureSelector,
                    makeDNA
                });
            }
        }

        function addChild(genealogy, childId, parentId) {
            if (!genealogy.has(parentId)) {
                genealogy.set(parentId, []);
            }

            genealogy.get(parentId).push(childId);
        }

        function addLog(logElement, line) {
            logElement.textContent += `\n${line}`;
        }

        function logEggCreated(logElement, egg) {
            addLog(
                logElement,
                `Egg Created: Containing ${egg.creature.id} | ${egg.initiatorId}, ${egg.otherId}`);
        }

        function logEggDestroyed(logElement, creature, egg) {
            addLog(
                logElement,
                `Egg Destroyed: By ${creature.id} | ${egg.initiatorId}, ${egg.otherId}`);
        }

        function updateTransform(context) {
            context.setTransform(
                transform.scale,
                0,
                0,
                transform.scale,
                -transform.xOffset * transform.scale,
                -transform.yOffset * transform.scale);
        }

        function scroll(x, y, context, xOffsetElement, yOffsetElement) {
            transform.xOffset = x;
            transform.yOffset = y;

            xOffsetElement.textContent = transform.xOffset;
            yOffsetElement.textContent = transform.yOffset;

            updateTransform(context);
        }

        function zoom(factor, center, context, scaleElement) {
            transform.scale *= factor;
            scaleElement.textContent = transform.scale;

            scroll(
                center.x - (center.x - transform.xOffset) / factor,
                center.y - (center.y - transform.yOffset) / factor,
                context,
                document.getElementById('xOffset'),
                document.getElementById('yOffset'));
        }

        function onLoad() {
            const view = document.getElementById('view');
            const simulationTimeItem = document.getElementById('simulationTime');
            const context = view.getContext('2d');
            context.imageSmoothingEnabled = false;

            const spriteCanvas = document.getElementById('sprite');
            const spriteContext = spriteCanvas.getContext('2d');
            spriteContext.imageSmoothingEnabled = false;
            spriteContext.scale(4, 4);
            spriteContext.translate(spriteWidth / 2, spriteHeight / 2);

            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            startButton.hidden = true;

            const logElement = document.getElementById('log');
            const elapsedSecondsElement = document.getElementById('elapsedSeconds');
            const updateSecondsElement = document.getElementById('updateSeconds');

            const genealogy = new Map();

            const environment = new world.Environment.Environment(
                {
                    eggs: [],
                    foodLocations: [],
                    width: mapWidth,
                    height: mapHeight
                },
                new Map(),
                new EnvironmentSelector({
                    foodGrowthPerTime: 30,
                    maximumFood: 50
                }),
                {
                    eatRadius: spriteWidth,
                    foodHealth: 750,
                    minimumCarnivores: 25,
                    minimumHerbivores: 25,
                    onEggCreated(egg, initiator, other) {
                        addChild(genealogy, egg.creature.id, initiator.id);

                        if (other) {
                            addChild(genealogy, egg.creature.id, other.id);
                        }

                        //logEggCreated(logElement, egg);
                    },
                    onEggDestroyed(creature, egg) {
                        //logEggDestroyed(logElement, creature, egg);
                    }
                });

            view.addEventListener('click', function(event) {
                const point = canvasToMap({
                    x: event.offsetX,
                    y: event.offsetY
                });
                handleClick(point, environment);
            });

            const graphviz = document.getElementById('graphviz');
            const renderGraphvizButton = document.getElementById('renderGraphviz');
            renderGraphvizButton.addEventListener('click', function(event) {
                renderGraphViz(genealogy, graphviz);
            });

            const speed = document.getElementById('speed');

            let rafHandle;
            let lastTime;
            const scale = 5000000;
            function process(currentTime) {
                const startTime = performance.now();

                rafHandle = requestAnimationFrame(process);

                if (!lastTime) {
                    lastTime = currentTime;
                }

                const elapsedSeconds =
                    ((currentTime - lastTime) * speed.valueAsNumber) / scale;
                lastTime = currentTime;
                elapsedSecondsElement.textContent = elapsedSeconds;
                try {
                    environment.process(elapsedSeconds);
                    render(context, environment);
                    simulationTimeItem.textContent = environment.simulationTime;

                    renderCreatureState(selectedCreature);
                }
                catch (e) {
                    console.log(e);
                }

                const endTime = performance.now();
                const updateElapsedSeconds = (endTime - startTime) / scale;
                updateSecondsElement.textContent = updateElapsedSeconds;
            }

            function run() {
                rafHandle = requestAnimationFrame(process)
            }

            function stop() {
                cancelAnimationFrame(rafHandle);
                rafHandle = undefined;
                lastTime = undefined;
            }

            startButton.addEventListener('click', () => {
                run();
                stopButton.hidden = false;
                startButton.hidden = true;
            });

            stopButton.addEventListener('click', () => {
                stop();
                stopButton.hidden = true;
                startButton.hidden = false;
            });

            const xOffsetElement = document.getElementById('xOffset');
            const yOffsetElement = document.getElementById('yOffset');
            document.addEventListener('keypress', function(e) {
                let dx = 0;
                let dy = 0;
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                        dy = -5;
                        e.preventDefault();
                        break;

                    case 'ArrowLeft':
                    case 'a':
                        dx = 5;
                        e.preventDefault();
                        break;

                    case 'ArrowDown':
                    case 's':
                        dy = 5;
                        e.preventDefault();
                        break;

                    case 'ArrowRight':
                    case 'd':
                        dx = -5;
                        e.preventDefault();
                        break;
                }

                scroll(
                    transform.xOffset + dx,
                    transform.yOffset + dy,
                    context,
                    xOffsetElement,
                    yOffsetElement);
            });

            const scaleElement = document.getElementById('scale');
            view.addEventListener('wheel', function(e) {
                e.preventDefault();

                let factor = 1;
                if (e.deltaY > 0) {
                    factor = 1/2;
                } else if (e.deltaY < 0) {
                    factor = 2;
                }

                const point = canvasToMap({
                    x: e.offsetX,
                    y: e.offsetY
                });

                zoom(factor, point, context, scaleElement);
            });

            view.addEventListener('mousemove', function(e) {
                const point = canvasToMap({
                    x: e.offsetX,
                    y: e.offsetY
                });

                document.getElementById('mouseX').textContent = point.x;
                document.getElementById('mouseY').textContent = point.y;
            });

            const center = {
                x: mapWidth / 2,
                y: mapHeight / 2
            };

            zoom(view.width / mapWidth, center, context, scaleElement);
            scroll(0, 0, context, xOffsetElement, yOffsetElement);
            run();
        }

        document.addEventListener('DOMContentLoaded', onLoad);
    </script>
</html>
