<!doctype html>
<html>
    <head>
        <title>Creatures</title>
        <meta charset="utf-8">
        <script src="../umd/world.js"></script>
        <style type="text/css">
            body {
                display: flex;
                justify-content: space-between;

                padding: 1em;
                margin: 0;
            }

            canvas {
                border: thin solid black;
            }

            #info {
                border-left: thin solid black;
                flex-grow: 1;
                padding-left: 1em;
            }

            #program {
                white-space: pre;
            }

            #creatureState {
                white-space: pre;
            }

            #graphviz {
                white-space: pre;
            }
        </style>
    </head>
    <body>
        <div>
            <canvas id="view" width="1000" height="1000"></canvas>
            <button id="startButton" type="button">Start</button>
            <button id="stopButton" type="button">Stop</button>
        </div>
        <div id="info">
            <div>
                <div id="settings">
                <dl>
                    <dt>Generation:</dt><dd id="generationCount"></dd>
                    <dt>Speed:</dt><dd><input id="speed" type="number" value="1"></dd>
                </dl>
            </div>
            <div>
                <div id="program">
                </div>
                <div>
                    <dl>
                        <dt>Id:</dt><dd id="creatureId"></dd>
                        <dt>Age:</dt><dd id="creatureAge"></dd>
                        <dt>Angle:</dt><dd id="creatureAngle"></dd>
                        <dt>Health:</dt><dd id="creatureHealth"></dd>
                        <dt>Speed:</dt><dd id="creatureSpeed"></dd>
                        <dt>X:</dt><dd id="creatureX"></dd>
                        <dt>Y:</dt><dd id="creatureY"></dd>
                    </dl>
                </div>
                <div id="creatureState">
                </div>
            </div>
            <div id="graphviz">
            </div>
        </div>
    </body>
    <script>
        function renderGraphViz(environment, graphviz) {
            let text = 'strict digraph {\n';
            environment.genealogy.forEach((parentIds, id) => {
                text += `\t"${id}" -> {`;
                parentIds.forEach(id => text += ` "${id}" `);
                text += '}\n';
            });

            text += `}`;

            graphviz.textContent = text;
        }

        let selectedCreature = null;

        const scaleFactor = 2;
        function mapToCanvas(point) {
            return {
                x: point.x / scaleFactor,
                y: point.y / scaleFactor
            };
        }

        function canvasToMap(point) {
            return {
                x: point.x * scaleFactor,
                y: point.y * scaleFactor
            };
        }

        function drawFood(context, point) {
            context.beginPath();
            context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            context.fillStyle = 'green';
            context.fill();
        }

        function getCreatureColor(creature) {
            const red = creature.isRed ? 255 : 0;
            const green = creature.isGreen ? 255 : 0;
            const blue = creature.isBlue ? 255 : 0
            return `rgb(${red}, ${green}, ${blue})`;
        }

        function drawCreature(context, creature) {
            const point = mapToCanvas(creature);

            context.beginPath();
            context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            context.fillStyle = getCreatureColor(creature);
            context.strokeStyle = `black`;
            context.fill();
            context.stroke();

            const healthWidth = Math.floor(creature.health * 10 / 4096);
            context.fillStyle = `rgb(0, 255, 0)`;
            context.fillRect(point.x - 5, point.y - 10, healthWidth, 3);
            context.fillStyle = `rgb(0, 0, 0)`;
            context.fillRect(point.x - 5 + healthWidth, point.y - 10, 10 - healthWidth, 3);

            if (selectedCreature === creature) {
                context.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                context.strokeStyle = 'rgb(0,0,255)';
                context.stroke();
            }

            const frustrumLength = 300 / scaleFactor;
            const frustrumAngle = Math.PI / 4;

            const leftEndpoint = {
                x: frustrumLength * Math.cos(creature.angle + frustrumAngle),
                y: frustrumLength * Math.sin(creature.angle + frustrumAngle)
            };

            const focusLeftEndpoint = {
                x: frustrumLength * Math.cos(creature.angle + frustrumAngle / 3),
                y: frustrumLength * Math.sin(creature.angle + frustrumAngle / 3)
            };

            context.strokeStyle = 'blue';

            context.beginPath();
            context.moveTo(point.x, point.y);
            context.lineTo(
                leftEndpoint.x + point.x,
                leftEndpoint.y + point.y);
            context.arc(
                point.x,
                point.y,
                frustrumLength,
                creature.angle + frustrumAngle,
                creature.angle - frustrumAngle,
                true);
            context.lineTo(point.x, point.y);
            context.stroke();

            context.strokeStyle = 'green';

            context.beginPath();
            context.moveTo(point.x, point.y);
            context.lineTo(
                focusLeftEndpoint.x + point.x,
                focusLeftEndpoint.y + point.y);
            context.arc(
                point.x,
                point.y,
                frustrumLength,
                creature.angle + frustrumAngle / 3,
                creature.angle - frustrumAngle / 3,
                true);
            context.lineTo(point.x, point.y);
            context.stroke();
        }

        function render(context, environment) {
            context.clearRect(
                0,
                0,
                context.canvas.width,
                context.canvas.height);

            environment.map.foodLocations.forEach(
                point => drawFood(context, mapToCanvas(point)));

            environment.creatures.forEach(
                creature => drawCreature(context, creature));
        }

        function distance(a, b) {
            return Math.sqrt(
                (a.x - b.x) * (a.x - b.x) +
                (a.y - b.y) * (a.y - b.y));
        }

        function handleClick(point, environment) {
            const creature = Array.from(environment.creatures.values()).
                find(creature => distance(point, creature) < 20);
            selectCreature(creature);
        }

        const renderedOperators = {
            [world.DNA.operators.greaterThan]: '>',
            [world.DNA.operators.lessThan]: '<',
            [world.DNA.operators.and]: 'and',
            [world.DNA.operators.or]: 'or',
            [world.DNA.operators.not]: 'not',
            [world.DNA.operators.add]: '+',
            [world.DNA.operators.subtract]: '-',
            [world.DNA.operators.multiply]: '*',
            [world.DNA.operators.divide]: '/'
        };

        function renderVariable(variable) {
            const known = {
                g: 'age',
                a: 'angle',
                A: 'angularV',
                h: 'health',
                s: 'speed',
                l: 'leftFoodDistance',
                r: 'rightFoodDistance',
                f: 'focusFoodDistance',
                H: 'leftCreatureDistance',
                L: 'rightCreatureDistance',
                P: 'focusCreatureDistance',
                W: 'frontSound',
                X: 'leftSound',
                Y: 'backSound',
                Z: 'rightSound'
            };

            if (variable in known) {
                return known[variable];
            }

            return variable;
        }

        function renderBoolean(boolean) {
            const known = {
                c: 'isRed',
                d: 'isGreen',
                e: 'isBlue',
                a: 'isAggressive',
                m: 'isMoving',
                F: 'isFast',
                I: 'leftCreatureIsRed',
                J: 'leftCreatureIsGreen',
                K: 'leftCreatureIsBlue',
                M: 'rightCreatureIsRed',
                N: 'rightCreatureisGreen',
                O: 'rightCreatureIsBlue',
                Q: 'focusCreatureIsRed',
                R: 'focusCreatureIsGreen',
                S: 'focusCreatureIsBlue'
            };

            if (boolean in known) {
                return known[boolean];
            }

            return boolean;
        }

        function renderTree(tree) {
            if (tree.operator === world.DNA.operators.constant) {
                return world.DNA.constants[tree.data].toString();
            } else if (tree.operator === world.DNA.operators.variable) {
                return renderVariable(tree.data);
            } else if (tree.operator === world.DNA.operators.true) {
                return 'T';
            } else if (tree.operator === world.DNA.operators.boolean) {
                return renderBoolean(tree.data);
            }

            const rhs = tree.rhs ? ` ${renderTree(tree.rhs)}` : '';

            return `(${renderTree(tree.lhs)} ${renderedOperators[tree.operator]}${rhs})`;
        }

        function renderGene(gene) {
            const output = gene.isBoolean ?
                renderBoolean(gene.output) :
                renderVariable(gene.output);
            return `if ${renderTree(gene.condition)}:\n\t${output} = ${renderTree(gene.expression)}\n`;
        }

        function renderProgram(creature) {
            const element = document.getElementById('program');
            if (creature) {
                const program = creature.dna.genes.reduce(
                    (aggregate, gene) => {
                        return aggregate += renderGene(gene);
                    },
                    '');

                element.textContent = program;
            } else {
                element.textContent = '';
            }
        }

        function renderCreatureState(creature) {
            if (creature) {
                document.getElementById('creatureId').textContent = creature.id;
                document.getElementById('creatureAge').textContent = creature.age;
                document.getElementById('creatureAngle').textContent = creature.angle;
                document.getElementById('creatureHealth').textContent = creature.health;
                document.getElementById('creatureSpeed').textContent = creature.speed;
                document.getElementById('creatureX').textContent = creature.x;
                document.getElementById('creatureY').textContent = creature.y;

                document.getElementById('creatureState').textContent =
                    JSON.stringify(creature.state, null, 2);
            } else {
                document.getElementById('creatureId').textContent = '';
                document.getElementById('creatureAge').textContent = '';
                document.getElementById('creatureAngle').textContent = '';
                document.getElementById('creatureHealth').textContent = '';
                document.getElementById('creatureSpeed').textContent = '';
                document.getElementById('creatureX').textContent = '';
                document.getElementById('creatureY').textContent = '';

                document.getElementById('creatureState').textContent = '';
            }
        }

        function selectCreature(creature) {
            selectedCreature = creature;
            renderProgram(creature);
        }

        function process(context, generationItem, environment, elapsedTimeMs) {
            environment.process(elapsedTimeMs / 1000);
            render(context, environment);
            generationItem.textContent = environment.generationCount;

            renderCreatureState(selectedCreature);
        }

        const dnaSelector = new world.DNA.GenericSelector({
            inputBooleans: 'IJKMNOQRS',
            inputVariables: 'lrfHLPWXYZ',
            maximumTreeDepth: 2,
            mutationsPerGene: new Map([
                [0, 0.9],
                [1, 0.93],
                [2, 0.95],
                [3, 0.99]
            ]),
            outputBooleans: 'amFcde',
            outputVariables: 'A',
            spliceRates: new Map([
                [world.DNA.spliceType.delete, 0.1],
                [world.DNA.spliceType.duplicate, 0.55],
                [world.DNA.spliceType.insert, 1]
            ])
        });

        const makeDNA = encodedDNA =>
            new world.DNA.DNA(encodedDNA, dnaSelector);

        class CreatureSelector extends world.Creature.GenericSelector {
            createRandomDNA() {
                return world.DNA.DNA.createRandom(dnaSelector, makeDNA);
            }
        }

        const creatureSelector = new CreatureSelector();

        const creatureStateProcessor = new world.Creature.StateProcessor(-10, 2000, 2000);

        class EnvironmentSelector extends world.Environment.GenericSelector {
            constructor(options) {
                super(options);
            }

            createRandomCreature() {
                return world.Creature.Creature.createRandom({
                    stateProcessor: creatureStateProcessor,
                    selector: creatureSelector,
                    makeDNA
                });
            }
        }

        function onLoad() {
            const view = document.getElementById('view');
            const generationItem = document.getElementById('generationCount');
            const context = view.getContext('2d');
            let isRunning = true;

            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            startButton.hidden = true;

            startButton.addEventListener('click', () => {
                isRunning = true;
                stopButton.hidden = !isRunning;
                startButton.hidden = isRunning;
            });

            stopButton.addEventListener('click', () => {
                isRunning = false;
                stopButton.hidden = !isRunning;
                startButton.hidden = isRunning;
            });

            const environment = new world.Environment.Environment(
                {
                    foodLocations: [],
                    width: view.width * scaleFactor,
                    height: view.height * scaleFactor
                },
                new Map(),
                new EnvironmentSelector({
                    foodGrowthPerTime: 30,
                    maximumFood: 50
                }),
                {
                    foodHealth: 200,
                    minimumCreatures: 50
                });

            view.addEventListener('click', function(event) {
                const point = canvasToMap({
                    x: event.offsetX,
                    y: event.offsetY
                });
                handleClick(point, environment);
            });

            const graphviz = document.getElementById('graphviz');

            const speed = document.getElementById('speed');
            function run() {
                if (isRunning) {
                    try {
                        process(context, generationItem, environment, 100);
                        renderGraphViz(environment, graphviz);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }

                setTimeout(run, 1000 / speed.valueAsNumber);
            }

            setTimeout(run, 1000 / speed.valueAsNumber);
        }

        document.addEventListener('DOMContentLoaded', onLoad);
    </script>
</html>
